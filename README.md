# Практикум №1 по предмету "Формальные языки и трансляции", МФТИ, ФИВТ, 3 семестр
Даны α и натуральные числа k, l, такие что 0 <= l < k. Вывести минимальное
число n, равное l по модулю k, такое что L содержит слова длины n.

Алгоритм представленного решения:
Заведем для каждого регулярного выражения массив v из k символов, причем v[i] 
означает минимальное такое число x, что слово длины x * k + i принадлежит языку,
задаваемому этим регулярным выражением. Если такого числа нет, то v[i] равно -1
Тогда случай букв/пустого слова примитивны([-1, 0, ..., -1] и [0, -1, ..., -1]
соответственно).
Для суммы языков в результирующем массиве будут числа-минимумы из соответсвующих 
индексов в случае их неотрицательности, -1 в случае если оба числа -1, оставшееся 
число, если в одном из массивов под этим индексом лежит -1. Сложность O(k).
Для конкатенации перебираются всевозможные пары индексов из двух массивов, 
смотрится сумма чисел под этими индексами и выбирается минимальная. Если одно из 
чисел под индексом отрицательно, такая сумма не рассматривается. Сложность O(k^2).
Для операции со звездой Клини применяется конкатенация массива с собой не более, чем 
k раз + учитывается, что пустое слово теперь всегда может быть задано этим рег.
выражением. Если результат не обновился после очередной конкатенации, то цикл 
останавливается.
Создаем стек из массивов и считываем посимвольно регулярное выражение.
1) Если встретили букву, добавляем на стек соответствующий ей массив
2) Если встретили операцию, то вынимаем со стека 1 или 2 массива(в зависимости от
операции), и получаем результирующий по описанным выше действиям.
В конце на стеке останется 1 массив answer. Ответом будет answer[l] + l.

Запуск программы в src/main.py. Так же алгоритм сопровождается unit-тестами в 
файле src/test_formal.py. Покрытие кода можно увидеть на скриншоте в репозитории.